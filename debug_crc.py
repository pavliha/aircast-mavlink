#!/usr/bin/env python3
"""
Debug CRC calculation to understand why we get different results
"""

import struct

def crc16_accumulate(data, crc=0xFFFF):
    """Calculate CRC16 for MAVLink messages - reference implementation"""
    for byte in data:
        tmp = byte ^ (crc & 0xFF)
        tmp = (tmp ^ (tmp << 4)) & 0xFF
        crc = ((crc >> 8) ^ (tmp << 8) ^ (tmp << 3) ^ (tmp >> 4)) & 0xFFFF
    return crc

def debug_crc_calculation():
    """Debug the exact CRC calculation for the problematic message"""
    print("Debugging CRC calculation for REQUEST_DATA_STREAM")
    print("=" * 60)
    
    # This is the current message being generated by aircast-mavlink:
    # fe 06 00 ff be 42 01 01 00 01 00 01 0b d8
    
    # Message data (excluding magic byte and checksum)
    length = 6
    seq = 0
    sys_id = 255
    comp_id = 190
    msg_id = 66
    payload = bytes([0x01, 0x01, 0x00, 0x01, 0x00, 0x01])
    
    print(f"Current message parameters:")
    print(f"  Length: {length}")
    print(f"  Sequence: {seq}")
    print(f"  System ID: {sys_id}")
    print(f"  Component ID: {comp_id}")
    print(f"  Message ID: {msg_id}")
    print(f"  Payload: {' '.join(f'{b:02x}' for b in payload)}")
    
    # Data to checksum
    data = struct.pack('BBBBB', length, seq, sys_id, comp_id, msg_id) + payload
    print(f"  Data to checksum: {' '.join(f'{b:02x}' for b in data)}")
    
    crc = crc16_accumulate(data)
    print(f"  CRC before CRC_EXTRA: 0x{crc:04x}")
    
    crc_extra = 148
    crc = crc16_accumulate([crc_extra], crc)
    print(f"  CRC after CRC_EXTRA {crc_extra}: 0x{crc:04x}")
    
    print(f"  Expected: 0x003c")
    print(f"  Match: {'YES' if crc == 0x003c else 'NO'}")
    
    print()
    print("Now testing one of the working combinations:")
    print("  target_system: 0, target_component: 2, req_stream_id: 178, req_message_rate: 1, start_stop: 1")
    print("  sequence: 0, sys_id: 1, comp_id: 1")
    
    # Working combination parameters
    length = 6
    seq = 0
    sys_id = 1
    comp_id = 1
    msg_id = 66
    payload = struct.pack('<BBBHB', 0, 2, 178, 1, 1)  # target_system, target_component, req_stream_id, req_message_rate, start_stop
    
    print(f"  Payload: {' '.join(f'{b:02x}' for b in payload)}")
    
    # Data to checksum
    data = struct.pack('BBBBB', length, seq, sys_id, comp_id, msg_id) + payload
    print(f"  Data to checksum: {' '.join(f'{b:02x}' for b in data)}")
    
    crc = crc16_accumulate(data)
    print(f"  CRC before CRC_EXTRA: 0x{crc:04x}")
    
    crc = crc16_accumulate([crc_extra], crc)
    print(f"  CRC after CRC_EXTRA {crc_extra}: 0x{crc:04x}")
    
    print(f"  Expected: 0x003c")
    print(f"  Match: {'YES' if crc == 0x003c else 'NO'}")
    
    # Full packet
    full_packet = struct.pack('<BBBBBB', 0xFE, length, seq, sys_id, comp_id, msg_id) + payload + struct.pack('<H', crc)
    print(f"  Full packet: {' '.join(f'{b:02x}' for b in full_packet)}")

if __name__ == "__main__":
    debug_crc_calculation()