import { TemplateEngine } from '../../src/generator/template-engine'
import Handlebars from 'handlebars'
import { TypeScriptDialect } from '../../src/types'

describe('TemplateEngine Handlebars Helpers - Type-safe Tests', () => {
  let engine: TemplateEngine

  beforeEach(() => {
    engine = new TemplateEngine()
  })

  describe('Helper Functions Direct Coverage', () => {
    test('should directly test eq helper', () => {
      // Access helpers through Handlebars
      const helpers = Handlebars.helpers
      const eqHelper = helpers.eq

      expect(eqHelper).toBeDefined()
      expect(eqHelper(5, 5)).toBe(true)
      expect(eqHelper('test', 'test')).toBe(true)
      expect(eqHelper(5, 10)).toBe(false)
      expect(eqHelper('test', 'other')).toBe(false)
      expect(eqHelper(null, null)).toBe(true)
      expect(eqHelper(undefined, undefined)).toBe(true)
      expect(eqHelper(null, undefined)).toBe(false)
    })

    test('should directly test ne helper', () => {
      const helpers = Handlebars.helpers
      const neHelper = helpers.ne

      expect(neHelper).toBeDefined()
      expect(neHelper(5, 5)).toBe(false)
      expect(neHelper('test', 'test')).toBe(false)
      expect(neHelper(5, 10)).toBe(true)
      expect(neHelper('test', 'other')).toBe(true)
      expect(neHelper(null, null)).toBe(false)
      expect(neHelper(undefined, undefined)).toBe(false)
      expect(neHelper(null, undefined)).toBe(true)
    })

    test('should directly test toUpperCase helper', () => {
      const helpers = Handlebars.helpers
      const toUpperCaseHelper = helpers.toUpperCase

      expect(toUpperCaseHelper).toBeDefined()
      expect(toUpperCaseHelper('hello')).toBe('HELLO')
      expect(toUpperCaseHelper('ALREADY_UPPER')).toBe('ALREADY_UPPER')
      expect(toUpperCaseHelper('mixedCase')).toBe('MIXEDCASE')
      expect(toUpperCaseHelper('')).toBe('')
      expect(toUpperCaseHelper('123abc')).toBe('123ABC')
    })

    test('should use helpers in template context', () => {
      // Create a test template that uses the helpers
      const testTemplate = Handlebars.compile(`
{{#if (eq value1 value2)}}Values are equal{{/if}}
{{#if (ne value1 value2)}}Values are not equal{{/if}}
{{toUpperCase text}}
      `)

      const result1 = testTemplate({ value1: 5, value2: 5, text: 'test' })
      expect(result1).toContain('Values are equal')
      expect(result1).not.toContain('Values are not equal')
      expect(result1).toContain('TEST')

      const result2 = testTemplate({ value1: 5, value2: 10, text: 'hello' })
      expect(result2).not.toContain('Values are equal')
      expect(result2).toContain('Values are not equal')
      expect(result2).toContain('HELLO')
    })
  })

  describe('generateSingle context functions', () => {
    test('should test generateTypes and generateMessages functions in single template context', () => {
      const mockDialect: TypeScriptDialect = {
        dialectName: 'test_context',
        enums: [
          {
            name: 'TEST_ENUM',
            description: ['Test enum'],
            values: [{ name: 'VALUE_1', value: 1, description: ['Value 1'] }],
            bitmask: false,
          },
        ],
        messages: [
          {
            id: 1,
            name: 'TEST_MESSAGE',
            originalName: 'TEST_MESSAGE',
            description: ['Test message'],
            fields: [
              {
                name: 'test_field',
                type: 'number',
                description: ['Test field'],
                optional: false,
              },
            ],
            crcExtra: 50,
          },
        ],
      }

      // This should trigger the context functions on lines 1189-1190
      const result = engine.generateSingle(mockDialect)

      expect(result).toBeDefined()
      expect(result).toContain('test_context')

      // The single template should include both types and messages content
      // generated by the context functions
      expect(result.length).toBeGreaterThan(100) // Should have substantial content
    })

    test('should verify context functions are called in single template', () => {
      // Create a spy on the internal methods
      const generateTypesSpy = jest.spyOn(engine, 'generateTypes')
      const generateMessagesSpy = jest.spyOn(engine, 'generateMessages')

      const mockDialect: TypeScriptDialect = {
        dialectName: 'test_spy',
        enums: [],
        messages: [],
      }

      // Generate single should call the context functions
      engine.generateSingle(mockDialect)

      // The context functions should be called with the dialect and false flag
      expect(generateTypesSpy).toHaveBeenCalledWith(
        expect.objectContaining({
          dialectName: 'test_spy',
          enums: [],
          messages: [],
        }),
        false
      )
      expect(generateMessagesSpy).toHaveBeenCalledWith(
        expect.objectContaining({
          dialectName: 'test_spy',
          enums: [],
          messages: [],
        }),
        false
      )

      generateTypesSpy.mockRestore()
      generateMessagesSpy.mockRestore()
    })
  })

  describe('Helper edge cases', () => {
    test('should handle eq helper with different types', () => {
      const helpers = Handlebars.helpers
      const eqHelper = helpers.eq

      // String vs Number
      expect(eqHelper('5', 5)).toBe(false)

      // Boolean comparisons
      expect(eqHelper(true, true)).toBe(true)
      expect(eqHelper(false, false)).toBe(true)
      expect(eqHelper(true, false)).toBe(false)

      // Array comparisons (reference equality)
      const arr = [1, 2, 3]
      expect(eqHelper(arr, arr)).toBe(true)
      expect(eqHelper([1, 2, 3], [1, 2, 3])).toBe(false)

      // Object comparisons (reference equality)
      const obj = { a: 1 }
      expect(eqHelper(obj, obj)).toBe(true)
      expect(eqHelper({ a: 1 }, { a: 1 })).toBe(false)
    })

    test('should handle ne helper with different types', () => {
      const helpers = Handlebars.helpers
      const neHelper = helpers.ne

      // String vs Number
      expect(neHelper('5', 5)).toBe(true)

      // Boolean comparisons
      expect(neHelper(true, true)).toBe(false)
      expect(neHelper(false, false)).toBe(false)
      expect(neHelper(true, false)).toBe(true)

      // Complex types
      expect(neHelper({}, {})).toBe(true) // Different objects
      expect(neHelper([], [])).toBe(true) // Different arrays
    })

    test('should handle toUpperCase helper with edge cases', () => {
      const helpers = Handlebars.helpers
      const toUpperCaseHelper = helpers.toUpperCase

      // Special characters
      expect(toUpperCaseHelper('hello-world_123')).toBe('HELLO-WORLD_123')
      expect(toUpperCaseHelper('café')).toBe('CAFÉ')
      expect(toUpperCaseHelper('привет')).toBe('ПРИВЕТ')

      // Non-string inputs (should convert to string first)
      expect(() => toUpperCaseHelper(null)).toThrow()
      expect(() => toUpperCaseHelper(undefined)).toThrow()
      expect(toUpperCaseHelper(String(123))).toBe('123')
      expect(toUpperCaseHelper(String(true))).toBe('TRUE')
    })
  })

  describe('Template compilation with helpers', () => {
    test('should compile template using eq helper in complex conditions', () => {
      const template = Handlebars.compile(`
{{#each items}}
  {{#if (eq type "enum")}}
    Enum: {{name}}
  {{else if (eq type "message")}}
    Message: {{name}}
  {{else}}
    Other: {{name}}
  {{/if}}
{{/each}}
      `)

      const data = {
        items: [
          { type: 'enum', name: 'TEST_ENUM' },
          { type: 'message', name: 'TEST_MESSAGE' },
          { type: 'other', name: 'TEST_OTHER' },
        ],
      }

      const result = template(data)
      expect(result).toContain('Enum: TEST_ENUM')
      expect(result).toContain('Message: TEST_MESSAGE')
      expect(result).toContain('Other: TEST_OTHER')
    })

    test('should compile template using ne helper in loops', () => {
      const template = Handlebars.compile(`
{{#each values}}
  {{#if (ne value 0)}}
    Non-zero: {{name}} = {{value}}
  {{/if}}
{{/each}}
      `)

      const data = {
        values: [
          { name: 'ZERO', value: 0 },
          { name: 'ONE', value: 1 },
          { name: 'TWO', value: 2 },
        ],
      }

      const result = template(data)
      expect(result).not.toContain('Non-zero: ZERO')
      expect(result).toContain('Non-zero: ONE = 1')
      expect(result).toContain('Non-zero: TWO = 2')
    })

    test('should compile template using toUpperCase in field names', () => {
      const template = Handlebars.compile(`
{{#each fields}}
  {{toUpperCase name}}: {{type}}
{{/each}}
      `)

      const data = {
        fields: [
          { name: 'field_one', type: 'uint8_t' },
          { name: 'field_two', type: 'uint16_t' },
        ],
      }

      const result = template(data)
      expect(result).toContain('FIELD_ONE: uint8_t')
      expect(result).toContain('FIELD_TWO: uint16_t')
    })
  })
})
